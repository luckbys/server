# üéØ Configura√ß√£o Frontend - Evolution Webhook Integration

## üìã Pr√©-requisitos

- Node.js 16+ instalado
- Frontend j√° configurado (React, Vue, Angular, etc.)
- Acesso ao servidor webhook: `https://webhook.bkcrm.devsible.com.br`

## üì¶ 1. Instala√ß√£o de Depend√™ncias

```bash
# Para comunica√ß√£o WebSocket em tempo real
npm install socket.io-client

# Para requisi√ß√µes HTTP (se n√£o tiver)
npm install axios
# ou usar fetch nativo do browser
```

## ‚öôÔ∏è 2. Configura√ß√£o de URLs

### Arquivo de configura√ß√£o (config.js)
```javascript
// config/api.js
const config = {
  development: {
    API_BASE_URL: 'http://localhost:3001/api',
    WEBSOCKET_URL: 'http://localhost:3001'
  },
  production: {
    API_BASE_URL: 'https://webhook.bkcrm.devsible.com.br/api',
    WEBSOCKET_URL: 'https://webhook.bkcrm.devsible.com.br'
  }
};

const isDevelopment = process.env.NODE_ENV === 'development';
export const API_CONFIG = isDevelopment ? config.development : config.production;
```

## üîå 3. Configura√ß√£o WebSocket (Tempo Real)

### React Hook - useEvolutionWebhook.js
```javascript
// hooks/useEvolutionWebhook.js
import { useEffect, useState, useCallback } from 'react';
import { io } from 'socket.io-client';
import { API_CONFIG } from '../config/api';

export function useEvolutionWebhook() {
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [messages, setMessages] = useState([]);
  const [instances, setInstances] = useState({});
  const [qrCodes, setQrCodes] = useState({});

  useEffect(() => {
    // Conectar ao WebSocket
    const newSocket = io(API_CONFIG.WEBSOCKET_URL, {
      transports: ['websocket'],
      timeout: 5000,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000
    });

    // Eventos de conex√£o
    newSocket.on('connect', () => {
      console.log('‚úÖ Conectado ao Evolution Webhook Server');
      setIsConnected(true);
    });

    newSocket.on('disconnect', () => {
      console.log('‚ùå Desconectado do Evolution Webhook Server');
      setIsConnected(false);
    });

    newSocket.on('connect_error', (error) => {
      console.error('‚ùå Erro de conex√£o WebSocket:', error);
    });

    // Status inicial do servidor
    newSocket.on('server-status', (data) => {
      console.log('üìä Status do servidor:', data);
    });

    // Nova mensagem recebida
    newSocket.on('new-message', (data) => {
      console.log('üì® Nova mensagem:', data);
      setMessages(prev => {
        // Evitar duplicatas
        const exists = prev.some(msg => msg.id === data.id);
        if (!exists) {
          return [data, ...prev].slice(0, 100); // Manter √∫ltimas 100 mensagens
        }
        return prev;
      });
    });

    // Atualiza√ß√£o de conex√£o de inst√¢ncia
    newSocket.on('connection-update', (data) => {
      console.log('üîó Status de conex√£o:', data);
      setInstances(prev => ({
        ...prev,
        [data.instance]: {
          ...prev[data.instance],
          status: data.status,
          statusReason: data.statusReason,
          lastUpdate: new Date()
        }
      }));
    });

    // QR Code atualizado
    newSocket.on('qr-updated', (data) => {
      console.log('üì± QR Code atualizado:', data.instance);
      if (data.qrCode) {
        setQrCodes(prev => ({
          ...prev,
          [data.instance]: data.qrCode
        }));
      }
    });

    // Startup da aplica√ß√£o
    newSocket.on('application-startup', (data) => {
      console.log('üöÄ Aplica√ß√£o iniciada:', data.instance);
      setInstances(prev => ({
        ...prev,
        [data.instance]: {
          ...prev[data.instance],
          status: 'started',
          lastUpdate: new Date()
        }
      }));
    });

    // Eventos gen√©ricos
    newSocket.on('generic-event', (data) => {
      console.log('üì® Evento gen√©rico:', data.event, data.instance);
    });

    setSocket(newSocket);

    // Cleanup
    return () => {
      newSocket.close();
    };
  }, []);

  // M√©todos para interagir com o WebSocket
  const joinInstance = useCallback((instanceName) => {
    if (socket && instanceName) {
      socket.emit('join-instance', instanceName);
      console.log(`üîå Entrando na sala da inst√¢ncia: ${instanceName}`);
    }
  }, [socket]);

  const leaveInstance = useCallback((instanceName) => {
    if (socket && instanceName) {
      socket.emit('leave-instance', instanceName);
      console.log(`üîå Saindo da sala da inst√¢ncia: ${instanceName}`);
    }
  }, [socket]);

  const pingServer = useCallback(() => {
    if (socket) {
      socket.emit('ping');
    }
  }, [socket]);

  const getInstanceStatus = useCallback((instanceName) => {
    if (socket && instanceName) {
      socket.emit('get-instance-status', instanceName);
    }
  }, [socket]);

  return {
    // Estado
    isConnected,
    messages,
    instances,
    qrCodes,
    
    // M√©todos
    joinInstance,
    leaveInstance,
    pingServer,
    getInstanceStatus,
    
    // Socket raw (para uso avan√ßado)
    socket
  };
}
```

### Vue Composable - useEvolutionWebhook.js
```javascript
// composables/useEvolutionWebhook.js
import { ref, onMounted, onUnmounted } from 'vue';
import { io } from 'socket.io-client';
import { API_CONFIG } from '../config/api';

export function useEvolutionWebhook() {
  const socket = ref(null);
  const isConnected = ref(false);
  const messages = ref([]);
  const instances = ref({});
  const qrCodes = ref({});

  const connect = () => {
    socket.value = io(API_CONFIG.WEBSOCKET_URL, {
      transports: ['websocket']
    });

    socket.value.on('connect', () => {
      isConnected.value = true;
    });

    socket.value.on('disconnect', () => {
      isConnected.value = false;
    });

    socket.value.on('new-message', (data) => {
      const exists = messages.value.some(msg => msg.id === data.id);
      if (!exists) {
        messages.value.unshift(data);
        messages.value = messages.value.slice(0, 100);
      }
    });

    socket.value.on('connection-update', (data) => {
      instances.value[data.instance] = {
        ...instances.value[data.instance],
        ...data
      };
    });

    socket.value.on('qr-updated', (data) => {
      if (data.qrCode) {
        qrCodes.value[data.instance] = data.qrCode;
      }
    });
  };

  const joinInstance = (instanceName) => {
    if (socket.value && instanceName) {
      socket.value.emit('join-instance', instanceName);
    }
  };

  onMounted(() => {
    connect();
  });

  onUnmounted(() => {
    if (socket.value) {
      socket.value.close();
    }
  });

  return {
    isConnected,
    messages,
    instances,
    qrCodes,
    joinInstance
  };
}
```

## üîÑ 4. Configura√ß√£o API REST

### Service para requisi√ß√µes HTTP
```javascript
// services/evolutionApi.js
import axios from 'axios';
import { API_CONFIG } from '../config/api';

class EvolutionApiService {
  constructor() {
    this.api = axios.create({
      baseURL: API_CONFIG.API_BASE_URL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    // Interceptor para logs
    this.api.interceptors.request.use(
      config => {
        console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`);
        return config;
      },
      error => {
        console.error('‚ùå API Request Error:', error);
        return Promise.reject(error);
      }
    );

    this.api.interceptors.response.use(
      response => {
        console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`);
        return response;
      },
      error => {
        console.error('‚ùå API Response Error:', error.response?.status, error.message);
        return Promise.reject(error);
      }
    );
  }

  // Health check
  async checkHealth() {
    try {
      const response = await this.api.get('/health');
      return response.data;
    } catch (error) {
      throw new Error(`Health check failed: ${error.message}`);
    }
  }

  // Buscar estat√≠sticas do servidor
  async getStats() {
    try {
      const response = await this.api.get('/stats');
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get stats: ${error.message}`);
    }
  }

  // Buscar inst√¢ncias
  async fetchInstances(instanceName = '') {
    try {
      const url = instanceName ? `/instance/fetchInstances?instanceName=${instanceName}` : '/instance/fetchInstances';
      const response = await this.api.get(url);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to fetch instances: ${error.message}`);
    }
  }

  // Buscar mensagens de uma inst√¢ncia
  async getMessages(instanceName, limit = 50, offset = 0) {
    try {
      const response = await this.api.get(`/messages/${instanceName}`, {
        params: { limit, offset }
      });
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get messages: ${error.message}`);
    }
  }

  // Enviar mensagem (simulado)
  async sendMessage(instance, to, message, type = 'text') {
    try {
      const response = await this.api.post('/send-message', {
        instance,
        to,
        message,
        type
      });
      return response.data;
    } catch (error) {
      throw new Error(`Failed to send message: ${error.message}`);
    }
  }
}

// Exportar inst√¢ncia √∫nica
export const evolutionApi = new EvolutionApiService();
```

## üéØ 5. Componentes de Exemplo

### React Component
```jsx
// components/EvolutionDashboard.jsx
import React, { useEffect, useState } from 'react';
import { useEvolutionWebhook } from '../hooks/useEvolutionWebhook';
import { evolutionApi } from '../services/evolutionApi';

function EvolutionDashboard() {
  const {
    isConnected,
    messages,
    instances,
    qrCodes,
    joinInstance
  } = useEvolutionWebhook();

  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(false);

  // Carregar estat√≠sticas
  const loadStats = async () => {
    setLoading(true);
    try {
      const statsData = await evolutionApi.getStats();
      setStats(statsData);
    } catch (error) {
      console.error('Erro ao carregar stats:', error);
    } finally {
      setLoading(false);
    }
  };

  // Enviar mensagem de teste
  const sendTestMessage = async () => {
    try {
      const result = await evolutionApi.sendMessage(
        'minha-instancia',
        '5511999999999@s.whatsapp.net',
        'Mensagem de teste do frontend!'
      );
      console.log('Mensagem enviada:', result);
    } catch (error) {
      console.error('Erro ao enviar mensagem:', error);
      alert('Erro ao enviar mensagem');
    }
  };

  useEffect(() => {
    loadStats();
    joinInstance('minha-instancia'); // Conectar √† sua inst√¢ncia
  }, [joinInstance]);

  return (
    <div className="evolution-dashboard">
      {/* Status de Conex√£o */}
      <div className={`connection-status ${isConnected ? 'connected' : 'disconnected'}`}>
        {isConnected ? 'üü¢ Conectado ao Webhook Server' : 'üî¥ Desconectado'}
      </div>

      {/* Controles */}
      <div className="controls">
        <button onClick={loadStats} disabled={loading}>
          {loading ? 'Carregando...' : 'Atualizar Stats'}
        </button>
        <button onClick={sendTestMessage}>
          Enviar Mensagem Teste
        </button>
      </div>

      {/* Estat√≠sticas */}
      {stats && (
        <div className="stats">
          <h3>üìä Estat√≠sticas do Servidor</h3>
          <p>Uptime: {Math.floor(stats.server.uptime)}s</p>
          <p>Mem√≥ria: {Math.round(stats.server.memory.rss / 1024 / 1024)}MB</p>
          <p>Clientes WebSocket: {stats.websocket.connectedClients}</p>
        </div>
      )}

      {/* QR Codes */}
      {Object.keys(qrCodes).length > 0 && (
        <div className="qr-codes">
          <h3>üì± QR Codes</h3>
          {Object.entries(qrCodes).map(([instance, qr]) => (
            <div key={instance} className="qr-code">
              <h4>{instance}</h4>
              <img src={qr} alt={`QR Code ${instance}`} style={{maxWidth: '200px'}} />
            </div>
          ))}
        </div>
      )}

      {/* Status das Inst√¢ncias */}
      <div className="instances">
        <h3>üîó Status das Inst√¢ncias</h3>
        {Object.entries(instances).map(([name, info]) => (
          <div key={name} className="instance">
            <span>{name}</span>
            <span className={`status ${info.status}`}>{info.status}</span>
          </div>
        ))}
      </div>

      {/* Mensagens Recentes */}
      <div className="messages">
        <h3>üí¨ Mensagens Recentes ({messages.length})</h3>
        <div className="message-list">
          {messages.map((msg, index) => (
            <div key={msg.id || index} className="message">
              <div className="message-header">
                <strong>{msg.pushName || msg.from}</strong>
                <small>{msg.instance}</small>
                <small>{new Date(msg.timestamp).toLocaleString()}</small>
              </div>
              <div className="message-content">
                <span className="message-type">[{msg.messageType}]</span>
                {msg.content}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

export default EvolutionDashboard;
```

### Vue Component
```vue
<!-- components/EvolutionDashboard.vue -->
<template>
  <div class="evolution-dashboard">
    <!-- Status de Conex√£o -->
    <div :class="['connection-status', isConnected ? 'connected' : 'disconnected']">
      {{ isConnected ? 'üü¢ Conectado ao Webhook Server' : 'üî¥ Desconectado' }}
    </div>

    <!-- Controles -->
    <div class="controls">
      <button @click="loadStats" :disabled="loading">
        {{ loading ? 'Carregando...' : 'Atualizar Stats' }}
      </button>
      <button @click="sendTestMessage">
        Enviar Mensagem Teste
      </button>
    </div>

    <!-- Estat√≠sticas -->
    <div v-if="stats" class="stats">
      <h3>üìä Estat√≠sticas do Servidor</h3>
      <p>Uptime: {{ Math.floor(stats.server.uptime) }}s</p>
      <p>Mem√≥ria: {{ Math.round(stats.server.memory.rss / 1024 / 1024) }}MB</p>
      <p>Clientes WebSocket: {{ stats.websocket.connectedClients }}</p>
    </div>

    <!-- QR Codes -->
    <div v-if="Object.keys(qrCodes).length > 0" class="qr-codes">
      <h3>üì± QR Codes</h3>
      <div v-for="[instance, qr] in Object.entries(qrCodes)" :key="instance" class="qr-code">
        <h4>{{ instance }}</h4>
        <img :src="qr" :alt="`QR Code ${instance}`" style="max-width: 200px" />
      </div>
    </div>

    <!-- Mensagens -->
    <div class="messages">
      <h3>üí¨ Mensagens Recentes ({{ messages.length }})</h3>
      <div class="message-list">
        <div v-for="(msg, index) in messages" :key="msg.id || index" class="message">
          <div class="message-header">
            <strong>{{ msg.pushName || msg.from }}</strong>
            <small>{{ msg.instance }}</small>
            <small>{{ new Date(msg.timestamp).toLocaleString() }}</small>
          </div>
          <div class="message-content">
            <span class="message-type">[{{ msg.messageType }}]</span>
            {{ msg.content }}
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue';
import { useEvolutionWebhook } from '../composables/useEvolutionWebhook';
import { evolutionApi } from '../services/evolutionApi';

export default {
  name: 'EvolutionDashboard',
  setup() {
    const { isConnected, messages, instances, qrCodes, joinInstance } = useEvolutionWebhook();
    
    const stats = ref(null);
    const loading = ref(false);

    const loadStats = async () => {
      loading.value = true;
      try {
        const statsData = await evolutionApi.getStats();
        stats.value = statsData;
      } catch (error) {
        console.error('Erro ao carregar stats:', error);
      } finally {
        loading.value = false;
      }
    };

    const sendTestMessage = async () => {
      try {
        const result = await evolutionApi.sendMessage(
          'minha-instancia',
          '5511999999999@s.whatsapp.net',
          'Mensagem de teste do frontend!'
        );
        console.log('Mensagem enviada:', result);
      } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        alert('Erro ao enviar mensagem');
      }
    };

    onMounted(() => {
      loadStats();
      joinInstance('minha-instancia');
    });

    return {
      isConnected,
      messages,
      instances,
      qrCodes,
      stats,
      loading,
      loadStats,
      sendTestMessage,
      Math
    };
  }
};
</script>
```

## üé® 6. CSS/Styling (Exemplo)

```css
/* styles/evolution-dashboard.css */
.evolution-dashboard {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

.connection-status {
  padding: 12px 20px;
  border-radius: 8px;
  font-weight: 600;
  margin-bottom: 20px;
  text-align: center;
}

.connection-status.connected {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.connection-status.disconnected {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.controls {
  margin: 20px 0;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.controls button {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  background: #007bff;
  color: white;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
}

.controls button:hover {
  background: #0056b3;
}

.controls button:disabled {
  background: #6c757d;
  cursor: not-allowed;
}

.stats {
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
  border: 1px solid #dee2e6;
}

.stats h3 {
  margin-top: 0;
  color: #495057;
}

.qr-codes {
  margin: 20px 0;
}

.qr-code {
  display: inline-block;
  margin: 10px;
  padding: 15px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: white;
  text-align: center;
}

.instances {
  margin: 20px 0;
}

.instance {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  margin: 5px 0;
  background: white;
}

.status {
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
}

.status.connected,
.status.open {
  background: #d4edda;
  color: #155724;
}

.status.disconnected,
.status.closed {
  background: #f8d7da;
  color: #721c24;
}

.messages {
  margin: 20px 0;
}

.message-list {
  max-height: 400px;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: white;
}

.message {
  padding: 15px;
  border-bottom: 1px solid #f0f0f0;
}

.message:last-child {
  border-bottom: none;
}

.message-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 14px;
}

.message-header strong {
  color: #007bff;
}

.message-header small {
  color: #6c757d;
}

.message-content {
  color: #495057;
}

.message-type {
  background: #e9ecef;
  color: #495057;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 11px;
  margin-right: 8px;
}
```

## üîß 7. Configura√ß√£o de Ambiente

### .env (Development)
```env
# .env.development
REACT_APP_API_BASE_URL=http://localhost:3001/api
REACT_APP_WEBSOCKET_URL=http://localhost:3001
```

### .env (Production)
```env
# .env.production
REACT_APP_API_BASE_URL=https://webhook.bkcrm.devsible.com.br/api
REACT_APP_WEBSOCKET_URL=https://webhook.bkcrm.devsible.com.br
```

## üß™ 8. Teste de Integra√ß√£o

```javascript
// utils/testIntegration.js
import { evolutionApi } from '../services/evolutionApi';

export async function testEvolutionIntegration() {
  console.log('üß™ Testando integra√ß√£o Evolution Webhook...');
  
  try {
    // Teste 1: Health check
    console.log('1. Testando health check...');
    const health = await evolutionApi.checkHealth();
    console.log('‚úÖ Health check OK:', health.status);
    
    // Teste 2: Estat√≠sticas
    console.log('2. Testando estat√≠sticas...');
    const stats = await evolutionApi.getStats();
    console.log('‚úÖ Stats OK:', stats.success);
    
    // Teste 3: Inst√¢ncias
    console.log('3. Testando busca de inst√¢ncias...');
    const instances = await evolutionApi.fetchInstances();
    console.log('‚úÖ Inst√¢ncias OK:', instances.length);
    
    console.log('üéâ Todos os testes passaram!');
    return true;
  } catch (error) {
    console.error('‚ùå Teste falhou:', error.message);
    return false;
  }
}

// Usar no componente ou durante desenvolvimento
// testEvolutionIntegration();
```

## üéØ 9. Checklist de Implementa√ß√£o

- [ ] Instalar depend√™ncias (`socket.io-client`, `axios`)
- [ ] Configurar URLs de desenvolvimento e produ√ß√£o
- [ ] Implementar hook/composable WebSocket
- [ ] Criar service para API REST
- [ ] Implementar componente dashboard
- [ ] Adicionar estilos CSS
- [ ] Configurar vari√°veis de ambiente
- [ ] Testar integra√ß√£o
- [ ] Conectar √† inst√¢ncia real do WhatsApp
- [ ] Deploy em produ√ß√£o

## üö® 10. Troubleshooting

### Problema: WebSocket n√£o conecta
```javascript
// Verificar CORS e URL
console.log('Tentando conectar em:', API_CONFIG.WEBSOCKET_URL);

// Testar manualmente
fetch(API_CONFIG.API_BASE_URL + '/health')
  .then(res => res.json())
  .then(data => console.log('API OK:', data))
  .catch(err => console.error('API Error:', err));
```

### Problema: CORS bloqueado
```javascript
// Verificar se o servidor est√° rodando com CORS habilitado
// O servidor j√° est√° configurado com: cors({ origin: "*" })
```

### Problema: Mensagens n√£o aparecem
```javascript
// Verificar se est√° conectado √† inst√¢ncia correta
useEffect(() => {
  if (isConnected) {
    joinInstance('SUA_INSTANCIA_AQUI'); // Nome correto da inst√¢ncia
  }
}, [isConnected, joinInstance]);
```

---

**‚úÖ Agora voc√™ tem tudo configurado para integrar seu frontend com o Evolution Webhook Server!**

**URLs importantes:**
- **Desenvolvimento**: `http://localhost:3001`
- **Produ√ß√£o**: `https://webhook.bkcrm.devsible.com.br`
- **Health Check**: `/api/health`
- **WebSocket**: Mesma URL base 